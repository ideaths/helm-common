# Example values.yaml structure for all updated templates
# This is a reference example and should be customized for each application

replicaCount: 3

image:
  repository: your-docker-registry.com/yourapp
  tag: "1.0.0"
  pullPolicy: IfNotPresent

imagePullSecrets:
  - name: registry-secret

nameOverride: ""
fullnameOverride: ""

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  # Optional settings for various service types
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
  # For service with multiple ports
  ports:
    - port: 80
      targetPort: 8080
      name: http
    - port: 9090
      targetPort: 9090
      name: metrics

# ConfigMap settings
configmap:
  create: true
  name: ""  # Optional, defaults to <release>-<chart>-config
  annotations: {}
  vars:
    APPLICATION_NAME: "my-app"
    CONFIG_VERSION: "1.0"
  serverConfigFiles:
    application.yaml: "files/application.yaml"
  # Alternative direct data configuration
  data:
    config.json: |
      {
        "database": {
          "host": "db-host",
          "port": 5432
        }
      }

# Secret settings
secret:
  enabled: true
  name: ""  # Optional, defaults to <release>-<chart>-secret
  annotations: {}
  type: Opaque
  # Data that should be base64 encoded automatically
  data:
    db-password: "your-db-password"
    api-key: "your-api-key"
  # Data that will be stored as-is (no base64 encoding)
  stringData:
    plain-text: "sample text"
  # Files to include as secret data
  dataFromFile:
    cert.pem: "files/certificates/cert.pem"

# Environment variables
env:
  enabled: true
  vars:
  - name: ENVIRONMENT
    value: "production"
  - name: LOG_LEVEL
    value: "info"
  - name: SECRET_REF
    valueFrom:
      secretKeyRef:
        name: my-secret
        key: password

# Liveness probe configuration
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 8080
  initialDelaySeconds: 60
  periodSeconds: 10
  timeoutSeconds: 2
  successThreshold: 1
  failureThreshold: 3

# Readiness probe configuration
readinessProbe:
  enabled: true
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 2
  successThreshold: 1
  failureThreshold: 3

# Resource requirements
resources:
  enabled: true
  limits:
    cpu: "500m"
    memory: "512Mi"
  requests:
    cpu: "250m"
    memory: "256Mi"

# Volume mounts and volumes
volumeMounts:
  create: true
  mountPoint:
    - name: config-volume
      mountPath: /etc/config
      readOnly: true
    - name: data-volume
      mountPath: /var/data
      readOnly: false

volumes:
  create: true
  mount:
    - name: config-volume
      configMap:
        name: app-config
        defaultMode: 420
        optional: false
        items:
          - key: app.conf
            path: app.conf
    - name: data-volume
      emptyDir: {}
    - name: secret-volume
      secret:
        secretName: app-secrets
        defaultMode: 420

# Pod security context
podSecurityContext:
  runAsUser: 1000
  runAsGroup: 1000
  fsGroup: 1000

# Container security context
securityContext:
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  allowPrivilegeEscalation: false
  privileged: false
  capabilities:
    drop:
      - ALL

# Horizontal Pod Autoscaler
hpa:
  enabled: true
  name: ""  # Optional, defaults to <release>-<chart>-hpa
  annotations: {}
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80
  # Advanced metrics configuration
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 80
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
  # Scaling behavior
  behavior:
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
      - type: Percent
        value: 50
        periodSeconds: 60
    scaleUp:
      stabilizationWindowSeconds: 0
      policies:
      - type: Percent
        value: 100
        periodSeconds: 30

# Ingress configuration
ingress:
  enabled: true
  className: nginx
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt-prod
  hosts:
    - host: myapp.example.com
      paths:
        - path: /api
          pathType: Prefix
          serviceName: ""  # Optional, defaults to chart name
          servicePort: 80
        - path: /admin
          pathType: Prefix
          serviceName: admin-service
          servicePort: 8080
      # Alternative single path format
      path: /
      pathType: Prefix
  tls:
    - secretName: myapp-tls
      hosts:
        - myapp.example.com

# Network policy configuration
networkPolicy:
  enabled: true
  name: ""  # Optional, defaults to <release>-<chart>-networkpolicy
  annotations: {}
  podSelector: {}  # Defaults to app's selector if not specified
  ingress:
    from:
      - podSelector:
          matchLabels:
            app: frontend
        ports:
          - protocol: TCP
            port: 80
      - namespaceSelector:
          matchLabels:
            monitoring: enabled
        ports:
          - protocol: TCP
            port: 9090
  egress:
    to:
      - podSelector:
          matchLabels:
            app: database
        ports:
          - protocol: TCP
            port: 5432
      - ipBlock:
          cidr: 10.0.0.0/16
          except:
            - 10.0.5.0/24

# Pod Disruption Budget
pdb:
  create: true
  name: ""  # Optional, defaults to <release>-<chart>-pdb
  annotations: {}
  minAvailable: 1  # Use either minAvailable or maxUnavailable
  # maxUnavailable: "50%"
  additionalSelectors: {}

# Service Account
serviceAccount:
  create: true
  name: ""  # Optional, defaults to <release>-<chart>
  annotations:
    eks.amazonaws.com/role-arn: "arn:aws:iam::123456789012:role/my-role"
  automountServiceAccountToken: true
  imagePullSecrets:
    - registry-secret

# OpenShift Route
route:
  enabled: false
  name: ""  # Optional, defaults to <release>-<chart>
  annotations: {}
  host: myapp.example.com
  path: /
  to:
    kind: Service
    name: ""  # Defaults to chart name
    weight: 100
  alternateBackends:
    - name: myapp-v2
      weight: 0
  targetPort: http
  wildcardPolicy: None
  tls:
    termination: edge
    insecureEdgeTerminationPolicy: Redirect
    key: |
      -----BEGIN PRIVATE KEY-----
      ...
      -----END PRIVATE KEY-----
    certificate: |
      -----BEGIN CERTIFICATE-----
      ...
      -----END CERTIFICATE-----
    caCertificate: |
      -----BEGIN CERTIFICATE-----
      ...
      -----END CERTIFICATE-----

# Istio configuration
istio:
  # Istio Gateway
  gateway:
    enabled: true
    name: ""  # Optional, defaults to <release>-<chart>-gateway
    annotations: {}
    selector:
      istio: ingressgateway
    hosts:
      - myapp.example.com
    enableHttps: true
    tlsMode: SIMPLE  # SIMPLE, MUTUAL, PASSTHROUGH
    credentialName: myapp-tls
    # Advanced server configuration
    servers:
      - port:
          number: 80
          name: http
          protocol: HTTP
        hosts:
          - "myapp.example.com"
        tls: {}
      - port:
          number: 443
          name: https
          protocol: HTTPS
        hosts:
          - "myapp.example.com"
        tls:
          mode: SIMPLE
          credentialName: myapp-tls

  # Istio Virtual Service
  virtualService:
    enabled: true
    name: ""  # Optional, defaults to <release>-<chart>-virtualservice
    annotations: {}
    hosts:
      - myapp.example.com
    gateways:
      - myapp-gateway
    # Simple configuration
    prefix: "/"
    destination:
      host: ""  # Defaults to service name
      port: 80
      subset: ""
      weight: 100
    # Advanced HTTP configuration
    http:
      - match:
          - uri:
              prefix: "/api"
          - uri:
              exact: "/health"
        route:
          - destination:
              host: myapp-service
              port:
                number: 80
        timeout: 5s
        retries:
          attempts: 3
          perTryTimeout: 2s

  # Istio Destination Rule
  destinationRule:
    enabled: true
    name: ""  # Optional, defaults to <release>-<chart>-destinationrule
    annotations: {}
    host: ""  # Defaults to service name
    subsets:
      - name: v1
        labels:
          version: v1
      - name: v2
        labels:
          version: v2
    trafficPolicy:
      loadBalancerType: ROUND_ROBIN  # Simple type
      loadBalancer:
        simple: ROUND_ROBIN  # Or detailed configuration
      connectionPool:
        tcp:
          maxConnections: 100
          connectTimeout: 30ms
        http:
          http1MaxPendingRequests: 100
          http2MaxRequests: 100
          maxRequestsPerConnection: 10
      outlierDetection:
        consecutive5xxErrors: 5
        interval: 1m
        baseEjectionTime: 30s
        maxEjectionPercent: 50
      tls:
        mode: ISTIO_MUTUAL

  # Istio Peer Authentication
  peerAuthentication:
    enabled: true
    name: ""  # Optional, defaults to <release>-<chart>-peerauth
    annotations: {}
    selector: {}  # Defaults to app's selector if not specified
    mtls:
      mode: STRICT  # STRICT, PERMISSIVE, DISABLE
    portLevelMtls:
      8080:
        mode: PERMISSIVE

  # Istio Authorization Policy
  authorizationPolicy:
    enabled: true
    name: ""  # Optional, defaults to <release>-<chart>-authz
    annotations: {}
    selector: {}  # Defaults to app's selector if not specified
    action: ALLOW  # ALLOW, DENY, AUDIT (v1beta1+)
    principal: "cluster.local/ns/default/sa/your-service-account"
    paths:
      - "/api/*"
      - "/admin"
    methods:
      - "GET"
      - "POST"
    # Advanced rules configuration
    rules:
      - from:
          - source:
              principals: ["cluster.local/ns/default/sa/service-a"]
        to:
          - operation:
              methods: ["GET"]
              paths: ["/api/v1/*"]
      - from:
          - source:
              namespaces: ["frontend"]
        to:
          - operation:
              methods: ["GET", "POST"]
              paths: ["/api/v1/*"]